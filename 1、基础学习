
1. 原子性（Atomicity）
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. 一致性（Consistency）
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

3. 隔离性（Isolation）
一个事务所做的修改在最终提交以前，对其它事务是不可见的。

4. 持久性（Durability）
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

只有满足一致性，事务的执行结果才是正确的。
在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
事务满足持久化是为了能应对系统崩溃的情况。


example1:Oracle
1、原子性：提供事务的完整管理模型，在系统的运行过程中实现事务的提交和回滚功能，以支持运行原子性，并且提供WAL日志和恢复机制
2、一致性：基于封锁技术的ss2pl（强两阶段提交协议）,支持多并发下的元数据一致；通过WAL和恢复机制，支持故障前后的数据一致。
3、隔离性：快照和多版本构成的MVCC技术实现并发事务对同一数据项的隔离。能实现一定并发下的不同场景的隔离，没有真正实现可串行化隔离。
4、持久性：预写WAL日志、恢复等技术实现数据的持久化存储。

(Oracle的封锁技术）




二、并发一致性
在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

丢失修改

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。


三、
读脏数据
T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。



不可重复读
T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。



幻影读
T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。



产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。
并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，
让用户以一种更轻松的方式处理并发一致性问题。


三、封锁性
平衡：X锁：互斥锁（exclusive）又称写锁
      S锁：共享锁，（shared) 读锁，当锁粒度大时，消耗资源大
  
  一个事务对数据对象加了X锁，可以对A进行读取和更新，加锁期间其他事务不能对事务加锁
  一个事务对数据对象加了S锁，可以对A 进行读操作，但是不能更新操作。加锁期间可对A加S锁，但是不能加X锁
  
  
  意象锁：（intension locks)
   	c存在行级锁和表级锁时，在原来的X/S锁上加了IX/IS意象锁，即：
   	一个事务在获得某个数据行对象的S锁前，需获得IS锁或更高级的锁
   	一个事务获得某个数据行对象的X锁前，需获得表的IX锁
   	
   	IS IX之间意向锁是兼容的，表示想对表加锁，不是真正的加锁

封锁协议：三级封锁协议
     1、一级封锁协议：事务T修改数据A，需要对A加X锁，T结束才可释放X锁，只有A加X锁，才可修改，避免出现丢失修改问题
     2、二级封锁协议：事务T想读数据A ,需要对A加S锁，读完才可是否S锁，只有A加S锁，避免出现脏数据问题。因为A如果被修改，需要加X锁，这样A不可被读
     3、三级封锁协议：在二级基础上，对A加S锁，当事务结束，才可是否S锁。